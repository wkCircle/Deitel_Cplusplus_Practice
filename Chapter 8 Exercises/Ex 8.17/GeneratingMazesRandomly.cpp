//8.17 well, this is copied from solution
#include "GeneratingMazesRandomly.hpp"
enum Direction {DOWN, RIGHT, UP, LEFT};
const int MAX_DOTS = 100; //max possible dots for maze.
const int arrSize = 12;
//function prototypes
void mazeTraversal( char [][12], const int, const int, int, int, int);
void mazeGenerator( char [][12],  int * , int * );
void printMaze( const char [][12] );
bool validMove( const char [][12], int, int );
bool coordsAreEdge( int, int );

// API function
void GeneratingMazesRandomly(){
    /* Generate a maze randomly.*/
	char maze[arrSize][arrSize];
	int xStart, yStart; // starting position
	int x, y; //current position

	srand(static_cast<unsigned int>(time(0))); // random seed

	//loop to generate hashes
	for ( int loop = 0; loop < arrSize; loop++ )
		for ( int loop2 = 0; loop2 < arrSize; loop2++)
			maze[loop][loop2] = '#';

	//generate the maze
	mazeGenerator(maze, &xStart, &yStart);

	//initialize x and y
	x = xStart;
	y = yStart;

	mazeTraversal(maze, xStart, yStart, x, y, RIGHT);
}//end GeneratingMazesRandomly()

//Assume that there is exactly one entrance and one exit.
void mazeTraversal( char maze[][12],
				    const int xStart, const int yStart, int xCoord, int yCoord, int direction){
    /*
    this function replaces Ex 8.16 (maze traversal)(recursive method.)
    This function helps walk through a maze, generated by the function GeneratingMazesRandomly(), by using the
    right-hand rule (RThumb in Ex 8.16).
    */
	static bool flag = false;

	maze[xCoord][yCoord] = 'x'; //initialize your first step at the entrance(xCoord, yCoord).
	printMaze( maze );

	//1. At the end, your posi should be on borders & not be the original entrance.
	if ( coordsAreEdge(xCoord, yCoord) && xCoord != xStart && yCoord !=yStart){
		cout << "Maze successfully exited.\n\n";
		return; //maze is completed.
	}
	//2. Back to entrance & flag==true condition.
	else if ( xCoord == xStart && yCoord == yStart && flag ){
		cout << "Arrived back at the starting location.\n\n";
		return;
	}
	// 3. flag assignment
	else{
		flag = true; //becomes true value as long as you sucessfully move.

		//for loop uses switch-case to determine appropriate move
		//count: for loop only runs at worst situaion 4 cases
		for ( int move = direction, count =0; count < 4; count++, move++, move%=4 ){

			switch (move) {
                /* RThumb: Place your right hand on the wall to your right and begin walking forward.
                Never remove your hand from the wall. If the maze turns to the right, you follow the wall to the right.*/
                ///core spirit: 1. According to RThumb, when it's case DOWN, you should do the recursive LEFT. Similar to other cases.
                /// 2. [Difficult!] You should judge DOWN -> RIGHT -> UP -> LEFT cases in order(break the order will lead to false algorithm),
                /// because validMove==false means that either your position is out of border or you bump into a wall. And based on RThumb,
                /// the judgement order should be the one described previously.
				case DOWN:
					if (validMove(maze, xCoord+1, yCoord)){
						mazeTraversal(maze, xStart, yStart, xCoord+1, yCoord, LEFT);
						return;
					}
					break;
				case RIGHT:
					if (validMove(maze, xCoord, yCoord+1)){
						mazeTraversal(maze, xStart, yStart, xCoord, yCoord+1, DOWN);
						return;
					}
					break;
				case UP:
					if (validMove(maze, xCoord-1, yCoord)){
						mazeTraversal(maze, xStart, yStart, xCoord-1, yCoord, RIGHT);
						return;
					}
					break;
				case LEFT:
					if (validMove(maze, xCoord, yCoord-1)){
						mazeTraversal(maze, xStart, yStart, xCoord, yCoord-1, UP);
						return;
					}
					break;
			}//end switch
			//Notice, If all 4 cases are false, break for loop and return.
		}//end for
	}//end if...else

}
bool validMove( const char maze[][12], int r, int c){
	//check the move is valid, i.e., not on the wall posi and doesn't break maze borders.
	return ( r>=0 && r<=12-1 && c>=0 && c<=12-1 && maze[r][c] != '#');
}
bool coordsAreEdge (int x, int y){
	//check if the posi is on the border of the maze or not.
	if ( ( x== 0 || x== 12-1) && ( y >= 0 && y <= 12-1)  )
		return true; // on borders.
	else if ( ( y== 0 || y== 12-1) && ( x >= 0 && x <= 12-1)  )
		return true; // on borders.
	else
		return false; // not on borders.
}
void printMaze( const char maze[][12]){
	for ( int x = 0; x < 12; x++){
		for ( int y = 0; y < 12; y++){
			cout << maze[x][y]<< ' ';
		}
		cout << '\n';
	}
	cout << "\nHit return to see next move.\n";
	cin.get();
}
void mazeGenerator( char maze[][12], int * xPtr, int *yPtr){
	int a; //store random numbers
	int entry, exit;
	int x, y;

	//Randomly initialize the entrance position.
	do {
		entry = rand() % 4;
		exit = rand() % 4;
	}while( entry == exit);

	//Determine entry position
	if ( entry == 0){ //LEFT
		*xPtr = rand() % (12-2) +1; //avoid corners.
		*yPtr = 0;
		maze[*xPtr][*yPtr] = '.';
	}
	else if ( entry == 1){ //UP
		*xPtr = 0;
		*yPtr = rand() % (12-2) +1; //avoid corners.
		maze[*xPtr][*yPtr] = '.';
	}
	else if ( entry == 2){ //DOWN
		*xPtr = rand() % (12-2) +1; //avoid corners.
		*yPtr = 12-1;
		maze[*xPtr][*yPtr] = '.';
	}
	else{ //RIGHT
		*xPtr = 12-1;
		*yPtr = rand() % (12-2) +1; //avoid corners.
		maze[*xPtr][*yPtr] = '.';
	}

	//Determine exit location
	if (exit == 0){ //LEFT
		a = rand() % (12-2) + 1;
		maze[a][0] = '.';
	}
	else if (exit == 1){ //UP
		a = rand() % (12-2) + 1;
		maze[0][a] = '.';
	}
	else if (exit == 2){ //DOWN
		a = rand() % (12-2) + 1;
		maze[a][12-1] = '.';
	}
	else{
		a = rand() % 10 + 1;
		maze[12-1][a] = '.';
	}

	//Generate paths (dots) in the interior of the maze.
	for (int loop = 1; loop < MAX_DOTS; loop++){
		x = rand() % (12-2) + 1;
		y = rand() % (12-2) + 1;
		maze[x][y] = '.';
	}//end for

}
